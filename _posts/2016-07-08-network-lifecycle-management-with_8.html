---
layout: post
title: Network Lifecycle Management with Hierarchical Configuration
date: '2016-07-08T11:26:00.001-05:00'
author: jtdub
tags:
- Cisco Administration Python Scripting
- Python Tips
- Network Programmability
- DevOps
- Network DevOps
- packetgeek.net
---

In a
<a href="https://www.packetgeek.net/2016/03/kicking-the-tires-on-the-new-ansible-network-modules-part-2/">
 previous blog
</a>
, I hinted at a network configuration life cycle management library called hierarchical_configuration. I've been meaning to write about it for a while, but we've been super busy at work. I also wanted to ensure that we get our latest version of the library out in the public for general consumption before I wrote about it.
<br/>
<br/>
As your fleet routers and switches grow, it becomes pretty natural to place these devices into a set of categories. For example, core, aggregation, and access. Each of these categories typically have a standard configuration. Hopefully each of these standard configurations exists as templates, so that new deployments can be rolled out quickly. But, what about making changes to the templates? Do you make changes to these templates, then continue to roll them out to new deployments, leaving the existing install base with an outdated configuration? Or do you return to the install base and remediate the devices with updated configurations? What if you have thousands of devices? This has been a problem that my colleagues and I have set out to solve. This is how hierarchical_configuration has evolved.
<br/>
<br/>
So, what is hierarchical_configuration? hierarchical_configuration is a python library that allows you to compare the running configuration and the intended configuration from a network device, then generate a set of commands that it will bring the network device into compliance with the intended configuration. hierarchical_configuration also has an extensive configuration file, so that you can define how specific commands or sections of commands get remediated.
<br/>
<br/>
Most utilities that performs a similar function as hierarchical_configuration, apply command remediation by negating a command, then applying the new command. For instance, if you wanted to change the interface description of an interface, most utilities will do something like:
<br/>
<pre class="lang:default decode:true">interface Ethernet0/1<br/> no description ROUTER1<br/> description ROUTER2<br/></pre>
<br/>
That works, but it's wasteful on CPU cycles, which slows down the over all application run time when you are attempting to apply interface descriptions to thousands of interfaces. What if the command was something that could be impactful, if it were negated? Maybe something like changing 'transport input ssh telnet' to 'transport input ssh', under your line vty? Negating the command could potentially cause you to lose management access.
<br/>
<br/>
hierarchical_configuration gives you several configuration options for dealing with such scenarios. You define those as a
<a href="http://yaml.org/" target="_blank">
 YAML
</a>
file under hier_options. Here is a sample of hier_options:
<br/>
<pre class="lang:default decode:true">---<br/>hier_tags:<br/>- lineage:<br/>  - startswith:<br/>    - ip access-list extended TEST<br/>    - no ip access-list extended TEST<br/>  add_tags: NEW_ACL<br/>- lineage:<br/>  - startswith: interface<br/>  - startswith: ip access-group TEST<br/>  add_tags: NEW_ACL<br/>- lineage:<br/>  - startswith:<br/>    - ip domain-name<br/>    - no ip domain-name<br/>    - ip domain-lookup<br/>    - no ip domain-lookup<br/>    - logging<br/>    - no logging<br/>    - snmp-server <br/>    - no snmp-server <br/>    - ntp server<br/>    - no ntp server<br/>    - ip tcp path-mtu-discovery<br/>    - ip access-list resequence<br/>  add_tags: safe <br/>- lineage:<br/>  - startswith: line<br/>  - startswith: exec-timeout<br/>  add_tags: safe <br/>- lineage:<br/>  - startswith: interface<br/>  - startswith: ip access-group<br/>  add_tags: unsafe <br/>- lineage:<br/>  - startswith: router ospf<br/>    new_in_config: false<br/>  - startswith:<br/>    - ispf<br/>    - nsf<br/>    - log<br/>  add_tags: safe <br/>- lineage: <br/>  - startswith: router ospf<br/>    new_in_config: false<br/>  - startswith:<br/>    - network <br/>    - area<br/>  add_tags: unsafe <br/><br/>hier_options:<br/>  #Indicates the style of the configuration<br/>  style: ios<br/><br/>  #if there is a delta, overwrite these parents instead of one of their children<br/>  sectional_overwrite:<br/>  - lineage:<br/>    - startswith: ipv6 access-list<br/><br/>  ordering:<br/>  - lineage:<br/>    - startswith:<br/>      - ip access-list<br/>      - access-list<br/>    order: 300<br/>  - lineage:<br/>    - startswith:<br/>      - tacacs-server host<br/>    order: 400<br/>  - lineage:<br/>    - startswith: interface<br/>    - startswith:<br/>      - ip access-group<br/>      - no ip access-group<br/>    order: 400<br/>  - lineage:<br/>    - startswith:<br/>      - no ip access-list<br/>      - no access-list<br/>      - no ip prefix-list<br/>      - no tacacs-server host<br/>    order: 590 <br/>  - lineage:<br/>    - contains: ip spd queue min-threshold<br/>    order: 601<br/>  - lineage:<br/>    - contains: ip spd queue max-threshold<br/>    order: 602<br/><br/>  sectional_overwrite_no_negate: []<br/><br/>  #adds +1 indent to lines following start_expression and removes the +1 indent for lines following end_expression<br/>  indent_adjust: []<br/><br/>  parent_allows_duplicate_child: []<br/><br/>  sectional_exiting:<br/>  - lineage:<br/>    - startswith: router bgp<br/>    - startswith: template peer-policy<br/>    exit_text: exit-peer-policy<br/>  - lineage:<br/>    - startswith: router bgp<br/>    - startswith: template peer-session<br/>    exit_text: exit-peer-session<br/>  - lineage:<br/>    - startswith: router bgp<br/>    - startswith: address-family<br/>    exit_text: exit-address-family<br/><br/>  #substitions against the full multi-line config text<br/>  full_text_sub:<br/>  - search: 'banner exec (\S+)\n(.*\n)+\\1\s*\n'<br/>    replace: ''<br/>  - search: 'banner motd (\S+)\n(.*\n)+\\1\s*\n'<br/>    replace: ''<br/><br/>  #substitions against each line of the config text<br/>  per_line_sub:<br/>  - search: ^Building configuration.*<br/>    replace: ''<br/>  - search: ^Current configuration.*<br/>    replace: ''<br/>  - search: ^! Last configuration change.*<br/>    replace: ''<br/>  - search: ^! NVRAM config last updated.*<br/>    replace: ''<br/>  - search: ^ntp clock-period .*<br/>    replace: ''<br/>  - search: .*message-digest-key.*<br/>    replace: ''<br/>  - search: ^version.*<br/>    replace: ''<br/>  - search: .*password.*<br/>    replace: ''<br/>  - search: ^ logging event link-status$<br/>    replace: ''<br/>  - search: ^ logging event subif-link-status$<br/>    replace: ''<br/>  - search: ^\s*ipv6 unreachables disable$<br/>    replace: ''<br/>  - search: ^\s*key .*<br/>    replace: ''<br/>  - search: ^end$<br/>    replace: ''<br/>  - search: '^\s*[#!].*'<br/>    replace: ''<br/>  - search: ^ no ip address<br/>    replace: ''<br/>  - search: ^ exit-peer-policy<br/>    replace: ''<br/>  - search: ^ exit-peer-session<br/>    replace: ''<br/>  - search: ^ exit-address-family<br/>    replace: ''<br/>  - search: ^crypto key generate rsa general-keys.*$<br/>    replace: ''<br/>  - search: .*key-string.*<br/>    replace: ''<br/><br/>  idempotent_commands_blacklist: []<br/><br/>  #These commands do not require negation, they simply overwrite themselves<br/>  idempotent_commands:<br/>  - lineage:<br/>    - startswith: hostname<br/>  - lineage:<br/>    - startswith: logging source-interface<br/>  - lineage:<br/>    - startswith: interface<br/>    - startswith: description<br/>  - lineage:<br/>    - startswith: interface<br/>    - startswith: ip address<br/>  - lineage:<br/>    - startswith: line vty<br/>    - startswith:<br/>      - transport input<br/>      - access-class<br/>      - ipv6 access-class<br/>  - lineage:<br/>    - startswith: interface<br/>    - re_search: standby \d+ (priority|authentication md5)<br/>  - lineage:<br/>    - startswith: router bgp<br/>    - startswith: bgp router-id<br/>  - lineage:<br/>    - startswith: router ospf<br/>    - startswith: router-id<br/>  - lineage:<br/>    - startswith: ipv6 router ospf<br/>    - startswith: router-id<br/>  - lineage:<br/>    - startswith: router ospf<br/>    - startswith: log-adjacency-changes<br/>  - lineage:<br/>    - startswith: ipv6 router ospf<br/>    - startswith: log-adjacency-changes<br/>  - lineage:<br/>    - startswith: router bgp<br/>    - re_search: neighbor \S+ description<br/>  - lineage:<br/>    - startswith: snmp-server community<br/>  - lineage:<br/>    - startswith: snmp-server location<br/>  - lineage:<br/>    - equals: line con 0<br/>    - startswith: exec-timeout<br/>  - lineage:<br/>    - startswith: interface<br/>    - startswith: ip ospf message-digest-key<br/>  - lineage:<br/>    - startswith: logging buffered<br/>  - lineage:<br/>    - startswith: tacacs-server key<br/>  - lineage:<br/>    - startswith: logging facility<br/>  - lineage:<br/>    - startswith: vlan internal allocation policy<br/><br/>  #Default when expression: list of expressions<br/>  negation_default_when: []<br/>  #- lineage:<br/>  #  - startswith: interface<br/><br/>  #Negate substitutions: expression -&gt; negate with<br/>  negation_negate_with: []<br/>  #- lineage:<br/>  #  - startswith: interface<br/>  #  use: command</pre>
<br/>
<br/>
<br/>
Lets break down the individual sections of hier_options. The first section is 'sectional_overwrite'. sectional_overwrite does exactly like it sounds. It over-writes an entire section of configuration if there is a change. In the example, it tags ipv6 access-lists as a section of code that should use sectional_overwrite.  If any changes are made to the intended configuration for ipv6 access-list, then hierarchical_configuration over writes the entire section of configuration, rather than targeting individual lines of children configuration in the section.
<br/>
<br/>
The next section is 'ordering'. Ordering is a very handy configuration option. It allows you to weight the order in which commands are presented in hierarchical_configuration. The default weight is 500. The smaller the number, the higher up in the configuration the commands are presented. While the commands tagged with larger numbers are presented lower in the configuration.
<br/>
<br/>
For instance, assume that you have an access-list called TEST, which is applied to Ethernet0/1:
<br/>
<pre class="lang:default decode:true">ip access-list TEST<br/> permit ip any host 1.1.1.1<br/>interface Ethernet0/1<br/> ip access-group TEST in</pre>
<br/>
Let's say that you want to create a new access-list called TESTING and apply it to Ethernet0/1, rendering the access-list TEST as un-needed. When you go to apply the configuration, you don't want to remove the access-list TEST before you've created access-list TESTING and applied it to interface Ethernet0/1. Doing so may impact traffic that is flowing across the interface. The preferable order of operation is:
<br/>
<ol>
 <br/>
 <li>
  Create the new access-list
 </li>
 <br/>
 <li>
  Apply the new access-list to the interface
 </li>
 <br/>
 <li>
  Remove the old access-list
 </li>
 <br/>
</ol>
<br/>
To do so, you will want to the command 'no ip access-list' closer to the bottom of the list of commands. You would do this, by setting the order of the negation of ip access-list higher than 500.
<br/>
<pre class="lang:default decode:true">  ordering:<br/>  - lineage:<br/>    - startswith:<br/>      - no ip access-list<br/>    order: 525<br/></pre>
<br/>
In this example, any command generated that starts with 'no ip access-list' gets tagged with an order of 525, which moves that section of configuration lower into the generated config. The generated configuration would look like:
<br/>
<pre class="lang:default decode:true">ip access-list TESTING<br/> permit ip any host 1.1.1.1<br/>interface Ethernet0/1<br/> ip access-group TESTING in<br/>no ip access-list TEST</pre>
<br/>
The next two sections are 'full_text_sub' and 'per_line_sub'. When you pull a running config from a device, it will typically contain some fluff, such as:
<br/>
<pre class="lang:default decode:true">#sh run<br/>Building configuration...<br/><br/>Current configuration : 9574 bytes<br/>!<br/>! Last configuration change at 19:51:43 CST Mon Apr 25 2016 by jtdub<br/>version 15.1</pre>
<br/>
That kind of text is just back ground noise, when we are attempting to determine the difference between the running config and the intended config. So, per_line_sub attempts to resolve that by ignoring it when comparing the configurations.
<br/>
<pre class="lang:default decode:true">  per_line_sub:<br/>  - search: ^Building configuration.*<br/>    replace: ''</pre>
<br/>
As you can see, it will find any line that contains 'Building configuration" and replace it with no data, effectively deleting the line. full_text_sub performs a similar task, but for entire sections of code. In our example, we ignore the banners on the device, as those can have information that is unique to the device.
<br/>
<pre class="lang:default decode:true">  full_text_sub:<br/>  - search: 'banner exec (\S+)\n(.*\n)+\\1\s*\n'<br/>    replace: ''<br/>  - search: 'banner motd (\S+)\n(.*\n)+\\1\s*\n'<br/>    replace: ''</pre>
<br/>
Hierarchical_configuration understands sections of config. It does this by assuming that a line of configuration that doesn't have any indentation to be a parent and any lines of configuration under the parent that have indentation are children of the parent. When the config reaches another line without indentation, the section of configuration ends. An example would be an interface configuration.
<br/>
<pre class="lang:default decode:true">interface Ethernet0/1       : Parent configuration section<br/> switchport                 : Child configuration section of interface Ethernet0/1<br/> switchport mode access     : Child configuration section of interface Ethernet0/1<br/> switchport access vlan 10  : Child configuration section of interface Ethernet0/1<br/>interface Ethernet0/2       : Parent configuration section<br/> no switchport              : Child configuration section of interface Ethernet0/2<br/> ip address 10.0.0.0/31     : Child configuration section of interface Ethernet0/2</pre>
<br/>
In some cases, there will be multiple tiers of parent / child configurations. An example would be peer templates in BGP.
<br/>
<pre class="lang:default decode:true">router bgp 65000          : Parent configuration section<br/> template peer-session RR : Child configuration section of 'router bgp 65000'<br/>  remote-as 65000         : Child configuration section of 'template peer-session RR'<br/>  update-source loopback0 : Child configuration section of 'template peer-session RR'<br/> exit-peer-session        : Sectional exit<br/> template peer-policy RR  : Child configuration section of 'router bgp 65000'<br/>  route-reflector-client  : Child configuration section of 'template peer-policy RR'<br/> exit-peer-policy         : Sectional exit</pre>
<br/>
With 'sectional_exiting', you can define sections of configuration that have sub-children of children, as explained above.
<br/>
<pre class="lang:default decode:true">  sectional_exiting:<br/>  - lineage:<br/>    - startswith: router bgp<br/>    - startswith: template peer-policy<br/>    exit_text: exit-peer-policy<br/>  - lineage:<br/>    - startswith: router bgp<br/>    - startswith: template peer-session<br/>    exit_text: exit-peer-session<br/>  - lineage:<br/>    - startswith: router bgp<br/>    - startswith: address-family<br/>    exit_text: exit-address-family</pre>
<br/>
'
<span class="s1">
 idempotent_commands' is the section where you define what should be over-written, rather than negated, then re-applied with new configuration. Commands such as hostname, description, ip address, etc should all be over-written, rather than negated.
</span>
<br/>
<pre class="lang:default decode:true">  idempotent_commands:<br/>  - lineage:<br/>    - startswith: hostname<br/>  - lineage:<br/>    - startswith: logging source-interface<br/>  - lineage:<br/>    - startswith: interface<br/>    - startswith: description<br/>  - lineage:<br/>    - startswith: interface<br/>    - startswith: ip address</pre>
<br/>
Another very handy set of options is command tagging, which resides in a different config section from hier_options, called hier_tags. Being able to tag commands allows you to generate remediation commands which target very specific commands, such as creating a new access-list, applying it, then removing the old access-list. We'll continue to use the examples that I've have above with replacing the access-list TEST with TESTING. The first thing we need to do is set up our tagging, which will look like:
<br/>
<pre class="lang:default decode:true">hier_tags:<br/>- lineage:<br/>  - startswith:<br/>    - ip access-list extended TEST<br/>    - no ip access-list extended TEST<br/>  add_tags: NEW_ACL<br/>- lineage:<br/>  - startswith: interface<br/>  - startswith: ip access-group TEST<br/>  add_tags: NEW_ACL<br/></pre>
<br/>
Assume that your running config is:
<br/>
<pre class="lang:default decode:true">hostname router<br/>!<br/>interface Ethernet0/1<br/> ip address 10.0.0.0/31<br/> ip access-group TEST in<br/>!<br/>interface Ethernet0/2<br/> ip address 10.0.0.2/31<br/>!<br/>ip access-list extended TEST<br/> permit ip any host 1.1.1.1<br/> permit ip any host 4.4.4.4<br/> permit ip any host 5.5.5.5<br/> permit ip any host 6.6.6.6<br/>!<br/>router ospf 1<br/> network 10.0.0.0 0.0.255.255 area 0<br/>!<br/>snmp-server community private<br/>!<br/>ntp server 11.22.33.44</pre>
<br/>
and your intended config is:
<br/>
<pre class="lang:default decode:true">hostname router<br/>!<br/>interface Ethernet0/1<br/> ip address 10.0.0.0/31<br/> ip access-group TESTING in<br/>!<br/>interface Ethernet0/2<br/> ip address 10.0.0.2/31<br/> ip access-group SOMEACL in<br/> ipv6 enable<br/> ipv6 filter TEST out <br/>!<br/>ip access-list extended TESTING<br/> permit ip any host 1.1.1.1<br/> permit ip any host 4.4.4.4<br/> permit ip any host 5.5.5.5<br/> permit ip any host 6.6.6.6<br/>!<br/>ip access-list extended SOMEACL<br/> permit ip any host 7.7.7.7<br/>!<br/>ipv6 access-list TEST<br/> permit ipv6 any 2001::1/128<br/>!<br/>router ospf 1<br/> network 10.0.0.0 0.0.255.255 area 0<br/>!<br/>snmp-server community private<br/>!<br/>ntp server 11.22.33.44</pre>
<br/>
We can use hierarchical_configuration compare the two configurations, make the appropriate configuration tag (NEW_ACL), then spit out a configuration plan based on the NEW_ACL tag.
<br/>
<br/>
Here is a sample output of the configuration comparison:
<br/>
<pre class="lang:default decode:true">$ ./example.py <br/><br/>{'comment': "new section, didn't exist before", 'text': 'ip access-list extended TESTING', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL']}<br/>{'comment': '', 'text': ' 10 permit ip any host 1.1.1.1', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL']}<br/>{'comment': '', 'text': ' 20 permit ip any host 4.4.4.4', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL']}<br/>{'comment': '', 'text': ' 30 permit ip any host 5.5.5.5', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL']}<br/>{'comment': '', 'text': ' 40 permit ip any host 6.6.6.6', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL']}<br/>{'comment': "new section, didn't exist before", 'text': 'ip access-list extended SOMEACL', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': '', 'text': ' 10 permit ip any host 7.7.7.7', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': '', 'text': 'interface Ethernet0/1', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL', 'unsafe']}<br/>{'comment': '', 'text': ' no ip access-group TEST in', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': '', 'text': ' ip access-group TESTING in', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL', 'unsafe']}<br/>{'comment': '', 'text': 'interface Ethernet0/2', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['unsafe']}<br/>{'comment': '', 'text': ' ip access-group SOMEACL in', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['unsafe']}<br/>{'comment': '', 'text': ' ipv6 enable', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': '', 'text': ' ipv6 filter TEST out', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': "new section, didn't exist before", 'text': 'ipv6 access-list TEST', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': '', 'text': ' permit ipv6 any 2001::1/128', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': 'removes 6 lines', 'text': 'no ip access-list extended TEST', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL']}</pre>
<br/>
As you can see, only the parts of the config pertaining to the TESTING access-list are tagged with the NEW_ACL tag. We can now generate a config plan based on that tag.
<br/>
<pre class="lang:default decode:true">$ ./example.py <br/><br/>Python dictionary of the comparison results<br/><br/>{'comment': "new section, didn't exist before", 'text': 'ip access-list extended TESTING', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL']}<br/>{'comment': '', 'text': ' 10 permit ip any host 1.1.1.1', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL']}<br/>{'comment': '', 'text': ' 20 permit ip any host 4.4.4.4', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL']}<br/>{'comment': '', 'text': ' 30 permit ip any host 5.5.5.5', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL']}<br/>{'comment': '', 'text': ' 40 permit ip any host 6.6.6.6', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL']}<br/>{'comment': "new section, didn't exist before", 'text': 'ip access-list extended SOMEACL', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': '', 'text': ' 10 permit ip any host 7.7.7.7', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': '', 'text': 'interface Ethernet0/1', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL', 'unsafe']}<br/>{'comment': '', 'text': ' no ip access-group TEST in', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': '', 'text': ' ip access-group TESTING in', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL', 'unsafe']}<br/>{'comment': '', 'text': 'interface Ethernet0/2', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['unsafe']}<br/>{'comment': '', 'text': ' ip access-group SOMEACL in', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['unsafe']}<br/>{'comment': '', 'text': ' ipv6 enable', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': '', 'text': ' ipv6 filter TEST out', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': "new section, didn't exist before", 'text': 'ipv6 access-list TEST', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': '', 'text': ' permit ipv6 any 2001::1/128', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': []}<br/>{'comment': 'removes 6 lines', 'text': 'no ip access-list extended TEST', 'post_exec_sleep': 0, 'post_exec_string': '', 'tags': ['NEW_ACL']}<br/><br/>Config plan based on NEW_ACL tag<br/><br/>ip access-list extended TESTING<br/> 10 permit ip any host 1.1.1.1<br/> 20 permit ip any host 4.4.4.4<br/> 30 permit ip any host 5.5.5.5<br/> 40 permit ip any host 6.6.6.6<br/>interface Ethernet0/1<br/> ip access-group TESTING in<br/>no ip access-list extended TEST</pre>
<br/>
Here is the script that produced the output:
<br/>
<pre class="lang:default decode:true">#!/usr/bin/env python<br/><br/>import yaml<br/><br/>from hierarchical_configuration import HierarchicalConfiguration<br/><br/>config_options = yaml.load(open('main.yml', 'r'))<br/>hier_tags = config_options['hier_tags']<br/>hier_options = config_options['hier_options']<br/><br/>running_config_hier = HierarchicalConfiguration(<br/>                          options=hier_options)<br/>running_config_hier.from_file('running.config')<br/><br/>compiled_config_hier = HierarchicalConfiguration(<br/>                           options=hier_options)<br/>compiled_config_hier.from_file('compiled.config')<br/><br/>remediation_config_hier = compiled_config_hier.deep_diff_tree_with(<br/>                              running_config_hier)<br/>remediation_config_hier.set_order_weight()<br/>remediation_config_hier.add_sectional_exiting()<br/>remediation_config_hier.add_tags(hier_tags)<br/><br/>print('\nPython dictionary of the comparison results\n')<br/>for command in remediation_config_hier.to_detailed_ouput():<br/>    print(command)<br/><br/>print('\nConfig plan based on NEW_ACL tag\n')<br/>for command in remediation_config_hier.to_detailed_ouput():<br/>    if 'NEW_ACL' in command['tags']:<br/>        print(command['text'])<br/></pre>
<br/>
Let's break down the script. The very first thing we do is import yaml and hierarchical_configuration:
<br/>
<pre class="lang:default decode:true">import yaml<br/><br/>from hierarchical_configuration import HierarchicalConfiguration</pre>
<br/>
Next, we read the hierarchical_configuration config file and define the options and tags variables:
<br/>
<pre class="lang:default decode:true">config_options = yaml.load(open('main.yml', 'r'))<br/>hier_tags = config_options['hier_tags']<br/>hier_options = config_options['hier_options']</pre>
<br/>
Now, we define an instance of hierarchical_configuration for the running config and load the running config from a file:
<br/>
<pre class="lang:default decode:true">running_config_hier = HierarchicalConfiguration(<br/>                          options=hier_options)<br/>running_config_hier.from_file('running.config')</pre>
<br/>
Then, we do the same for the intended config:
<br/>
<pre class="lang:default decode:true">compiled_config_hier = HierarchicalConfiguration(<br/>                           options=hier_options)<br/>compiled_config_hier.from_file('compiled.config')</pre>
<br/>
Once that is done, we can perform the comparison:
<br/>
<pre class="lang:default decode:true">remediation_config_hier = compiled_config_hier.deep_diff_tree_with(<br/>                              running_config_hier)</pre>
<br/>
Now, we load the ordering, sectional exiting, and tags options:
<br/>
<pre class="lang:default decode:true">remediation_config_hier.set_order_weight()<br/>remediation_config_hier.add_sectional_exiting()<br/>remediation_config_hier.add_tags(hier_tags)</pre>
<br/>
At this point, everything is loaded into memory. The next two portions of code are simply to have a visual of what is happening. The first portion is a for-loop, which displays the raw list of dictionaries:
<br/>
<pre class="lang:default decode:true">print('\nPython dictionary of the comparison results\n')<br/>for command in remediation_config_hier.to_detailed_ouput():<br/>    print(command)</pre>
<br/>
Finally, the finished product. Generating a config plan, based on the NEW_ACL tag.
<br/>
<pre class="lang:default decode:true">print('\nConfig plan based on NEW_ACL tag\n')<br/>for command in remediation_config_hier.to_detailed_ouput():<br/>    if 'NEW_ACL' in command['tags']:<br/>        print(command['text'])</pre>
<br/>
As you can see, hierarchical configuration is a very powerful life-cycle management tool for network gear. We've been using it successfully on IOS, IOS-XR, IOS-XE, NX-OS, and EOS devices. It has made our work less risky - from an outage perspective - more consistent, and allows us to automate and move faster than we have in previous years.
<br/>
<br/>
The code is available on Github
<a href="https://github.com/jtdub/hierarchical_configuration" target="_blank">
 here
</a>
.

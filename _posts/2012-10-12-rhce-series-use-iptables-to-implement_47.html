---
layout: post
title: |-
  RHCE Series: Use iptables to implement packet filtering and configure
  network address translation (NAT): Part 1
date: '2012-10-12T18:59:00.001-05:00'
author: jtdub
tags:
- IPTables
- Linux
- RHCE Study Notes
- packetgeek.net
---

This section is on using IPTables to create a packet filtering firewall as well as implementing NAT with IPTables. My test environment are two stock installs of CentOS 6.3 in a virtualized environment.
<br/>
<br/>
The VM's:
<br/>
<ul>
 <br/>
 <li>
  server1:
  <br/>
  <ul>
   <br/>
   <li>
    eth0: dhcp has access to the Internet
   </li>
   <br/>
   <li>
    eth1: static address of 192.168.101.1/24, internal network.
   </li>
   <br/>
   <li>
    Server1 acts as the firewall / NAT router
   </li>
   <br/>
  </ul>
  <br/>
 </li>
 <br/>
 <li>
  client1:
  <br/>
  <ul>
   <br/>
   <li>
    eth0: static address of 192.168.101.101
   </li>
   <br/>
   <li>
    Client1 acts as a computer on an internal network.
   </li>
   <br/>
  </ul>
  <br/>
 </li>
 <br/>
 <li>
  client2:
  <br/>
  <ul>
   <br/>
   <li>
    eth0: static address of 192.168.101.102
   </li>
   <br/>
   <li>
    Client2 acts as a computer on an internal network.
   </li>
   <br/>
  </ul>
  <br/>
 </li>
 <br/>
</ul>
<br/>
The first thing that I did on server1 was make sure that I had a clean slate to work with. That included making sure that my firewall had a default setting of allowing all traffic, but wasn't forwarding any traffic. I also verified my interfaces and routing table.
<br/>
<br/>
<br/>
<pre>[root@server1 ~]# iptables -F<br/>[root@server1 ~]# service iptables save<br/>iptables: Saving firewall rules to /etc/sysconfig/iptables:[  OK  ]<br/>[root@server1 ~]# iptables -L<br/>Chain INPUT (policy ACCEPT)<br/>target     prot opt source               destination         <br/><br/>Chain FORWARD (policy ACCEPT)<br/>target     prot opt source               destination         <br/><br/>Chain OUTPUT (policy ACCEPT)<br/>target     prot opt source               destination         <br/>[root@server1 ~]# ip addr show<br/>1: lo:  mtu 16436 qdisc noqueue state UNKNOWN <br/>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br/>    inet 127.0.0.1/8 scope host lo<br/>    inet6 ::1/128 scope host <br/>       valid_lft forever preferred_lft forever<br/>2: eth0:  mtu 1500 qdisc pfifo_fast state UP qlen 1000<br/>    link/ether 52:54:00:f0:36:20 brd ff:ff:ff:ff:ff:ff<br/>    inet 192.168.122.74/24 brd 192.168.122.255 scope global eth0<br/>    inet6 fe80::5054:ff:fef0:3620/64 scope link <br/>       valid_lft forever preferred_lft forever<br/>3: eth1:  mtu 1500 qdisc pfifo_fast state UP qlen 1000<br/>    link/ether 52:54:00:b3:38:d1 brd ff:ff:ff:ff:ff:ff<br/>    inet 192.168.101.1/24 brd 192.168.101.255 scope global eth1<br/>    inet6 fe80::5054:ff:feb3:38d1/64 scope link <br/>       valid_lft forever preferred_lft forever<br/>[root@server1 ~]# ip route show<br/>192.168.101.0/24 dev eth1  proto kernel  scope link  src 192.168.101.1 <br/>192.168.122.0/24 dev eth0  proto kernel  scope link  src 192.168.122.74 <br/>169.254.0.0/16 dev eth0  scope link  metric 1002 <br/>169.254.0.0/16 dev eth1  scope link  metric 1003 <br/>default via 192.168.122.1 dev eth0</pre>
<br/>
I did the same thing on client1 and client2:
<br/>
<br/>
<br/>
<pre>[root@client1 ~]# iptables -F<br/>[root@client1 ~]# service iptables save<br/>iptables: Saving firewall rules to /etc/sysconfig/iptables:[  OK  ]<br/>[root@client1 ~]# ip addr show<br/>1: lo:  mtu 16436 qdisc noqueue state UNKNOWN <br/>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br/>    inet 127.0.0.1/8 scope host lo<br/>    inet6 ::1/128 scope host <br/>       valid_lft forever preferred_lft forever<br/>2: eth0:  mtu 1500 qdisc pfifo_fast state UP qlen 1000<br/>    link/ether 52:54:00:38:28:0a brd ff:ff:ff:ff:ff:ff<br/>    inet 192.168.101.101/24 brd 192.168.101.255 scope global eth0<br/>    inet6 fe80::5054:ff:fe38:280a/64 scope link <br/>       valid_lft forever preferred_lft forever<br/>[root@client1 ~]# ip route show<br/>192.168.101.0/24 dev eth0  proto kernel  scope link  src 192.168.101.101 <br/>169.254.0.0/16 dev eth0  scope link  metric 1002 <br/>default via 192.168.101.1 dev eth0 <br/>[root@client1 ~]# ping -c 1 192.168.101.1 &amp;&amp; ping -c 1 4.2.2.2<br/>PING 192.168.101.1 (192.168.101.1) 56(84) bytes of data.<br/>64 bytes from 192.168.101.1: icmp_seq=1 ttl=64 time=0.333 ms<br/><br/>--- 192.168.101.1 ping statistics ---<br/>1 packets transmitted, 1 received, 0% packet loss, time 0ms<br/>rtt min/avg/max/mdev = 0.333/0.333/0.333/0.000 ms<br/>PING 4.2.2.2 (4.2.2.2) 56(84) bytes of data.<br/><br/>--- 4.2.2.2 ping statistics ---<br/>1 packets transmitted, 0 received, 100% packet loss, time 10000ms</pre>
<br/>
Here is some of the functionality that IPTables provides:
<br/>
<br/>
<br/>
<pre>[root@server1 ~]# iptables --help<br/>iptables v1.4.7<br/><br/>Usage: iptables -[AD] chain rule-specification [options]<br/>       iptables -I chain [rulenum] rule-specification [options]<br/>       iptables -R chain rulenum rule-specification [options]<br/>       iptables -D chain rulenum [options]<br/>       iptables -[LS] [chain [rulenum]] [options]<br/>       iptables -[FZ] [chain] [options]<br/>       iptables -[NX] chain<br/>       iptables -E old-chain-name new-chain-name<br/>       iptables -P chain target [options]<br/>       iptables -h (print this help information)<br/><br/>Commands:<br/>Either long or short options are allowed.<br/>  --append  -A chain  Append to chain<br/>  --delete  -D chain  Delete matching rule from chain<br/>  --delete  -D chain rulenum<br/>    Delete rule rulenum (1 = first) from chain<br/>  --insert  -I chain [rulenum]<br/>    Insert in chain as rulenum (default 1=first)<br/>  --replace -R chain rulenum<br/>    Replace rule rulenum (1 = first) in chain<br/>  --list    -L [chain [rulenum]]<br/>    List the rules in a chain or all chains<br/>  --list-rules -S [chain [rulenum]]<br/>    Print the rules in a chain or all chains<br/>  --flush   -F [chain]  Delete all rules in  chain or all chains<br/>  --zero    -Z [chain [rulenum]]<br/>    Zero counters in chain or all chains<br/>  --new     -N chain  Create a new user-defined chain<br/>  --delete-chain<br/>            -X [chain]  Delete a user-defined chain<br/>  --policy  -P chain target<br/>    Change policy on chain to target<br/>  --rename-chain<br/>            -E old-chain new-chain<br/>    Change chain name, (moving any references)<br/>Options:<br/>[!] --proto -p proto protocol: by number or name, eg. `tcp'<br/>[!] --source -s address[/mask][...]<br/>    source specification<br/>[!] --destination -d address[/mask][...]<br/>    destination specification<br/>[!] --in-interface -i input name[+]<br/>    network interface name ([+] for wildcard)<br/> --jump -j target<br/>    target for rule (may load target extension)<br/>  --goto      -g chain<br/>                              jump to chain with no return<br/>  --match -m match<br/>    extended match (may load extension)<br/>  --numeric -n  numeric output of addresses and ports<br/>[!] --out-interface -o output name[+]<br/>    network interface name ([+] for wildcard)<br/>  --table -t table table to manipulate (default: `filter')<br/>  --verbose -v  verbose mode<br/>  --line-numbers  print line numbers when listing<br/>  --exact -x  expand numbers (display exact values)<br/>[!] --fragment -f  match second or further fragments only<br/>  --modprobe=<command/>  try to insert modules using this command<br/>  --set-counters PKTS BYTES set the counter during insert/append<br/>[!] --version -V  print package version.</pre>
<br/>
The remaining functionality can be found in 'man iptables'. There is A LOT of functionality! However, the RHCE objectives state that you should be able to create a packet filtering firewall. Note that it doesn't state anything about needing to create a modern stateful packet inspection firewall. It also states that you should be able to create a NAT.
<br/>
<br/>
Let's start with a packet filtering firewall. IPtables reads the rules from the top down and will process it's responses based upon the first matching rule.
<br/>
<br/>
In this first example. I created two rules. The first one blocks all ICMP traffic from 192.168.101.101 (client1), while the second permits all ICMP traffic from 192.168.101.102 (client2).
<br/>
<br/>
<br/>
<pre>[root@server1 ~]# iptables -L<br/>Chain INPUT (policy ACCEPT)<br/>target     prot opt source               destination         <br/><br/>Chain FORWARD (policy ACCEPT)<br/>target     prot opt source               destination         <br/><br/>Chain OUTPUT (policy ACCEPT)<br/>target     prot opt source               destination         <br/>[root@server1 ~]# ping -c 1 192.168.101.101<br/>PING 192.168.101.101 (192.168.101.101) 56(84) bytes of data.<br/>64 bytes from 192.168.101.101: icmp_seq=1 ttl=64 time=0.434 ms<br/><br/>--- 192.168.101.101 ping statistics ---<br/>1 packets transmitted, 1 received, 0% packet loss, time 0ms<br/>rtt min/avg/max/mdev = 0.434/0.434/0.434/0.000 ms<br/>[root@server1 ~]# ping -c 1 192.168.101.102<br/>PING 192.168.101.102 (192.168.101.102) 56(84) bytes of data.<br/>64 bytes from 192.168.101.102: icmp_seq=1 ttl=64 time=0.263 ms<br/><br/>--- 192.168.101.102 ping statistics ---<br/>1 packets transmitted, 1 received, 0% packet loss, time 0ms<br/>rtt min/avg/max/mdev = 0.263/0.263/0.263/0.000 ms<br/>[root@server1 ~]# iptables -I INPUT -s 192.168.101.101/32 -p icmp -j REJECT<br/>[root@server1 ~]# iptables -I INPUT -s 192.168.101.102/32 -p icmp -j ACCEPT<br/>[root@server1 ~]# iptables -L<br/>Chain INPUT (policy ACCEPT)<br/>target     prot opt source               destination         <br/>ACCEPT     icmp --  192.168.101.102      anywhere            <br/>REJECT     icmp --  192.168.101.101      anywhere            reject-with icmp-port-unreachable <br/><br/>Chain FORWARD (policy ACCEPT)<br/>target     prot opt source               destination         <br/><br/>Chain OUTPUT (policy ACCEPT)<br/>target     prot opt source               destination         <br/>[root@server1 ~]# ping -c 1 192.168.101.101<br/>PING 192.168.101.101 (192.168.101.101) 56(84) bytes of data.<br/><br/>--- 192.168.101.101 ping statistics ---<br/>1 packets transmitted, 0 received, 100% packet loss, time 10000ms<br/><br/>[root@server1 ~]# ping -c 1 192.168.101.102<br/>PING 192.168.101.102 (192.168.101.102) 56(84) bytes of data.<br/>64 bytes from 192.168.101.102: icmp_seq=1 ttl=64 time=0.569 ms<br/><br/>--- 192.168.101.102 ping statistics ---<br/>1 packets transmitted, 1 received, 0% packet loss, time 0ms<br/>rtt min/avg/max/mdev = 0.569/0.569/0.569/0.000 ms</pre>
<br/>
As you can see in the example above, I started out with a default, permit anything, rule set. I then verified that I could ping both client1 and client2. Finally, I applied the two rules and attempted to ping the hosts again. The ping request to client1 failed, while was successful on client2.
<br/>
<br/>
Now, why did the server fail to ping client1 when we wanted pings from client1 to server1 to fail? The answer is that when server1 sent a ping (echo-request), client1 responded to the ping (echo). Since the rule blocks ALL icmp types. The rule blocked the response (echo) from client1, but allowed the echo-request from server1.
<br/>
<br/>
Below are the attempted ping requests from client1 and client2 before and after I applied the firewall rules to block icmp.
<br/>
<br/>
<br/>
<pre class="crayon-selected">###Before###<br/>[root@client1 ~]# ping -c 1 192.168.101.1<br/>PING 192.168.101.1 (192.168.101.1) 56(84) bytes of data.<br/>64 bytes from 192.168.101.1: icmp_seq=1 ttl=64 time=0.320 ms<br/><br/>--- 192.168.101.1 ping statistics ---<br/>1 packets transmitted, 1 received, 0% packet loss, time 0ms<br/>rtt min/avg/max/mdev = 0.320/0.320/0.320/0.000 ms<br/>[root@client1 ~]# ping -c 1 192.168.101.102<br/>PING 192.168.101.102 (192.168.101.102) 56(84) bytes of data.<br/>64 bytes from 192.168.101.102: icmp_seq=1 ttl=64 time=1.16 ms<br/><br/>--- 192.168.101.102 ping statistics ---<br/>1 packets transmitted, 1 received, 0% packet loss, time 1ms<br/>rtt min/avg/max/mdev = 1.166/1.166/1.166/0.000 ms<br/>###After###<br/>[root@client1 ~]# ping -c 1 192.168.101.1<br/>PING 192.168.101.1 (192.168.101.1) 56(84) bytes of data.<br/>From 192.168.101.1 icmp_seq=1 Destination Port Unreachable<br/><br/>--- 192.168.101.1 ping statistics ---<br/>1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms<br/><br/>[root@client1 ~]# ping -c 1 192.168.101.102<br/>PING 192.168.101.102 (192.168.101.102) 56(84) bytes of data.<br/>64 bytes from 192.168.101.102: icmp_seq=1 ttl=64 time=0.270 ms<br/><br/>--- 192.168.101.102 ping statistics ---<br/>1 packets transmitted, 1 received, 0% packet loss, time 0ms<br/>rtt min/avg/max/mdev = 0.270/0.270/0.270/0.000 ms<br/><br/><br/>###Before###<br/>[root@client2 ~]# ping -c 1 192.168.101.1<br/>PING 192.168.101.1 (192.168.101.1) 56(84) bytes of data.<br/>64 bytes from 192.168.101.1: icmp_seq=1 ttl=64 time=0.526 ms<br/><br/>--- 192.168.101.1 ping statistics ---<br/>1 packets transmitted, 1 received, 0% packet loss, time 0ms<br/>rtt min/avg/max/mdev = 0.526/0.526/0.526/0.000 ms<br/>[root@client2 ~]# ping -c 1 192.168.101.101<br/>PING 192.168.101.101 (192.168.101.101) 56(84) bytes of data.<br/>64 bytes from 192.168.101.101: icmp_seq=1 ttl=64 time=0.236 ms<br/><br/>--- 192.168.101.101 ping statistics ---<br/>1 packets transmitted, 1 received, 0% packet loss, time 0ms<br/>rtt min/avg/max/mdev = 0.236/0.236/0.236/0.000 ms<br/>###After###<br/>[root@client2 ~]# ping -c 1 192.168.101.1<br/>PING 192.168.101.1 (192.168.101.1) 56(84) bytes of data.<br/>64 bytes from 192.168.101.1: icmp_seq=1 ttl=64 time=0.531 ms<br/><br/>--- 192.168.101.1 ping statistics ---<br/>1 packets transmitted, 1 received, 0% packet loss, time 0ms<br/>rtt min/avg/max/mdev = 0.531/0.531/0.531/0.000 ms<br/>[root@client2 ~]# ping -c 1 192.168.101.101<br/>PING 192.168.101.101 (192.168.101.101) 56(84) bytes of data.<br/>64 bytes from 192.168.101.101: icmp_seq=1 ttl=64 time=0.749 ms<br/><br/>--- 192.168.101.101 ping statistics ---<br/>1 packets transmitted, 1 received, 0% packet loss, time 0ms<br/>rtt min/avg/max/mdev = 0.749/0.749/0.749/0.000 ms</pre>
<br/>
Let's break down the IPTables ruleset:
<br/>
<br/>
<br/>
<pre>iptables -I INPUT -s 192.168.101.101/32 -p icmp -j REJECT</pre>
<br/>
Directly after the iptables command, you have the '-I' switch followed by the word INPUT. iptables
<span style="background-color: yellow;">
 -I INPUT
</span>
.
<br/>
<br/>
The -I option specifies insert and INPUT is the chain name. INPUT is for incoming traffic.
<br/>
<br/>
Here are some other options:
<br/>
<br/>
<br/>
<pre>  --append  -A chain  Append to chain<br/>  --delete  -D chain  Delete matching rule from chain<br/>  --delete  -D chain rulenum<br/>    Delete rule rulenum (1 = first) from chain<br/>  --insert  -I chain [rulenum]<br/>    Insert in chain as rulenum (default 1=first)<br/>  --replace -R chain rulenum<br/>    Replace rule rulenum (1 = first) in chain<br/>  --list    -L [chain [rulenum]]<br/>    List the rules in a chain or all chains<br/>  --list-rules -S [chain [rulenum]]<br/>    Print the rules in a chain or all chains<br/>  --flush   -F [chain]  Delete all rules in  chain or all chains<br/>  --zero    -Z [chain [rulenum]]<br/>    Zero counters in chain or all chains<br/>  --new     -N chain  Create a new user-defined chain<br/>  --delete-chain<br/>            -X [chain]  Delete a user-defined chain<br/>  --policy  -P chain target<br/>    Change policy on chain to target<br/>  --rename-chain<br/>            -E old-chain new-chain<br/>    Change chain name, (moving any references)</pre>
<br/>
Be default, in the *filter table there are three chains. Those types are INPUT, FORWARD, and OUTPUT. In the *nat table there are PREROUTING, POSTROUTING, and OUTPUT. You can also create new chains with the -N switch.
<br/>
<br/>
The next option was to specify a source with
<span style="background-color: yellow;">
 -s 192.168.101.101/32
</span>
. With this you can specify entire subnets, individual IP Addresses, hostname, or you can get creative and specify custom chains with groups of addresses. Another common option is the -i option, which lets you specify the incoming interface.
<br/>
<br/>
After specifying a source you need to specify a destination. If the -d is left off, all traffic will hit the filter. Next is the protocol with the -p option. In this case,
<span style="background-color: yellow;">
 -p icmp
</span>
. You can use tcp, udp, udplite, icmp, esp, ah, sctp, or all as protocols. With tcp or udp, you will also specify port numbers with the --dport or --sport option, depending on source or destination port. You can specify a single port like
<span style="background-color: yellow;">
 --dport 22
</span>
, a range of ports like
<span style="background-color: yellow;">
 --dport 20:23
</span>
, or individual ports like
<span style="background-color: yellow;">
 --dport 21,22,25
</span>
.
<br/>
<br/>
Lastly, you decide what to do with the traffic with the -j option. The most common options are ACCEPT, DROP, and REJECT. In this case I decided to accept the traffic.
<span style="background-color: yellow;">
 -j ACCEPT
</span>
.
<br/>
<br/>
As this was a rather long section. I'll split this into two parts. Part two will cover NAT.

---
layout: post
title: Kicking the tires on the new Ansible Network Modules, Part 2
date: '2016-03-01T18:28:00.001-06:00'
author: jtdub
tags:
- Python Tips
- Network Programmability
- DevOps
- Network DevOps
- Ansible
modified_time: '2019-04-11T11:10:07.246-05:00'
blogger_id: tag:blogger.com,1999:blog-2200496390325245811.post-4305012201179656270
blogger_orig_url: https://www.packetgeek.net/2016/03/kicking-tires-on-new-ansible-network_1.html
---

In the <a href="http://www.packetgeek.net/2016/02/kicking-the-tires-with-the-new-ansible-network-modules/">previous blog</a>, I kicked the tires on the ios_command and ios_config Ansible modules. I still had my development environment set up from then, so I decided that I wanted to kick the tires on the ios_template module.<br/><br/>The <a href="http://docs.ansible.com/ansible/ios_template_module.html" target="_blank">online documentation</a> currently has several errors, with the module documentation in the same state, which is undesirable. However, after some experimentation, I feel that I can adequately describe what the module does.<br/><br/>You feed the module a candidate configuration for a device, the module will then reach out to the device, pull its current running configuration, compare the running configuration to the candidate configuration, determine what configuration needs to be added to the device based upon the comparison, then add the configuration to the device.<br/><br/>I've noted two caveats with this module. First, it will not negate any commands, so if you update your configuration template to remove a swath of configuration, the module will not make those changes. Second, the module isn't intelligent enough to determine the risk associated with a command, thus it's unable to take preemptive actions, such as bleeding traffic from a link or device.<br/><br/>With that in mind, let's get to the playbook.<br/><br/>Here is what my playbook looks like:<br/><pre class="lang:yaml decode:true ">---<br/>- hosts: ios<br/>  gather_facts: no<br/>  connection: local<br/><br/>  tasks:<br/>  - name: OBTAIN LOGIN CREDENTIALS<br/>    include_vars: secrets.yaml<br/><br/>  - name: DEFINE PROVIDER<br/>    set_fact:<br/>      provider:<br/>        host: "{{ "{{" }} inventory_hostname }}"<br/>        username: "{{ "{{" }} creds['username'] }}"<br/>        password: "{{ "{{" }} creds['password'] }}"<br/>        auth_pass: "{{ "{{" }} creds['auth_pass'] }}"<br/><br/>  - name: TEST IOS_TEMPLATE <br/>    ios_template:<br/>      provider: "{{ "{{" }} provider }}"<br/>      authorize: true<br/>      backup: true<br/>      src: "{{ "{{" }} inventory_hostname }}.candidate_config.txt"<br/>    register: template<br/><br/>  - debug: var=template</pre><br/>In this playbook, the src file - "<em>{{ "{{" }} inventory_hostname }}.candidate_config.txt</em>", which are referenced, contain the running configuration of each of my devices in inventory, with the exception that I've added an access-list called TEST. Given what we know of the module, it will compare the running config to the candidate config, determine that the access-list called TEST is missing from the running config, and attempt to add the access-list to the device.<br/><br/>You can see below that there is an access-list at the tail end of both of the configurations.<br/><pre class="lang:default decode:true">(env)jtdub-macbook:ansible2.0 jtdub$ tail edge1.candidate_config.txt <br/>!<br/>ntp source Vlan2<br/>ntp access-group peer NAT kod<br/>ntp master 3<br/>ntp update-calendar<br/>ntp server 17.151.16.21<br/>ntp server 17.151.16.34 prefer<br/>ip access-list standard TEST<br/> permit host 1.1.1.1<br/>end<br/>(env)jtdub-macbook:ansible2.0 jtdub$ tail aggr1a.candidate_config.txt <br/> exec-timeout 15 0<br/> login authentication auth_local<br/> transport input ssh<br/>line vty 5 15<br/>!<br/>ntp source Vlan2<br/>ntp server 172.16.1.1 prefer<br/>ip access-list standard TEST<br/> permit host 1.1.1.1<br/>end<br/></pre><br/>Now, if we run the playbook, you can see the results.<br/><pre class="lang:yaml decode:true">(env)jtdub-macbook:ansible2.0 jtdub$ ansible-playbook -i hosts ios_template.yaml <br/><br/>PLAY [ios] *********************************************************************<br/><br/>TASK [OBTAIN LOGIN CREDENTIALS] ************************************************<br/>ok: [edge1]<br/>ok: [aggr1a]<br/><br/>TASK [DEFINE PROVIDER] *********************************************************<br/>ok: [aggr1a]<br/>ok: [edge1]<br/><br/>TASK [TEST IOS_TEMPLATE] *******************************************************<br/>changed: [aggr1a]<br/>changed: [edge1]<br/><br/>TASK [debug] *******************************************************************<br/>ok: [edge1] =&gt; {<br/>    "template": {<br/>        "changed": true, <br/>        "responses": [<br/>            "", <br/>            "", <br/>            ""<br/>        ], <br/>        "updates": [<br/>            "clock summer-time CST recurring", <br/>            "ip access-list standard TEST", <br/>            "permit host 1.1.1.1"<br/>        ]<br/>    }<br/>}<br/>ok: [aggr1a] =&gt; {<br/>    "template": {<br/>        "changed": true, <br/>        "responses": [<br/>            "", <br/>            ""<br/>        ], <br/>        "updates": [<br/>            "ip access-list standard TEST", <br/>            "permit host 1.1.1.1"<br/>        ]<br/>    }<br/>}<br/><br/>PLAY RECAP *********************************************************************<br/>aggr1a                     : ok=4    changed=1    unreachable=0    failed=0   <br/>edge1                      : ok=4    changed=1    unreachable=0    failed=0   <br/><br/>(env)jtdub-macbook:ansible2.0 jtdub$ <br/></pre><br/>That is definitely cool! Though, it's also definitely lacking from a configuration intent perspective. I'm sure that it will improve with time.<br/><br/>Some colleagues and I have been attempting to solve this configuration intent problem. It's a difficult problem to solve for, but we have a working code base. Soon, I'll try to write about configuration intent and how we are approaching the problem.
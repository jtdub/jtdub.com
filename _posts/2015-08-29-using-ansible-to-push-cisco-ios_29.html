---
layout: post
title: Using Ansible to PUSH Cisco IOS Configurations
date: '2015-08-29T11:16:00.001-05:00'
author: jtdub
tags:
- Cisco Administration Python Scripting
- IOS
- Python Tips
- Network Programmability
- DevOps
- Network DevOps
- Ansible
- IOS-XE
- IOS-XR
modified_time: '2019-04-11T11:10:05.879-05:00'
blogger_id: tag:blogger.com,1999:blog-2200496390325245811.post-5294505561141099555
blogger_orig_url: https://www.packetgeek.net/2015/08/using-ansible-to-push-cisco-ios_29.html
---

There are a lot of very good articles on the Internet about how Network Engineers can use Ansible to create standardized network device configurations or use Ansible with existing network vendor API's to make changes to network devices. Some of my favorites can be found on the
<a href="https://pynet.twb-tech.com/blog/" target="_blank">
 Python for Network Engineers
</a>
and
<a href="http://jedelman.com/" target="_blank">
 Jason Edelman's
</a>
sites.
<br/>
<br/>
However, what if you have [older, legacy] network devices or are running on software revisions that don't support the newer vendor API's? What if you need to push a common configuration among a multi-vendor or multi-platform of devices quickly? Pushing configurations quickly is easy with my
<a href="https://github.com/jtdub/pyMultiChange" target="_blank">
 PyMultiChange
</a>
tool, but one of its biggest limitations is a multi-[vendor, platform] support - where common configurations may have differing syntax, by [vendor, platform] to accomplish the same task. I have yet to find any blogs on Google that share ideas of this category.
<br/>
<br/>
For a while, this led me to believe that it it just wasn't possible, unless you invested the time in developing the appropriate Ansible modules.  However, I had an idea the other day, which proved that it is possible to push configurations to this category of network devices.
<br/>
<br/>
Here is my example playbook:
<br/>
<pre class="lang:default decode:true">---<br/>- hosts: netdevices<br/>  connection: local<br/>  gather_facts: no<br/>  <br/>  tasks:<br/>  - name: Create SNMP Configuration<br/>    template:<br/>      src=templates/snmp-contact.j2<br/>      dest=input/{{ "{{" }} hostname }}.conf<br/>    delegate_to: 127.0.0.1<br/><br/>  - name: Configure SNMP Contact on network device<br/>    command: scripts/netsible.py {{ "{{" }} hostname }} input/{{ "{{" }} hostname }}.conf <br/>    delegate_to: 127.0.0.1</pre>
<br/>
In this playbook, you can see that I call a group of devices call 'netdevices'. The first play is to generate the configuration. In this case, I am modifying the snmp-server contact information. It calls a source template called snmp-contact.j2. Here is what the template looks like:
<br/>
<pre class="lang:default decode:true">config t<br/>snmp-server contact {{ "{{" }} contact_name }}<br/>end<br/>copy run start<br/><br/></pre>
<br/>
The template calls the 'contact_name' variable and destination of the template is in the input directory and named using the 'hostname' variable.
<br/>
<br/>
The hostname variable is called from host_vars. Here is the host_var for a test device, called core1a:
<br/>
<pre class="lang:default decode:true">hostname: core1a</pre>
<br/>
The contact_name variable is called from group_vars/all. Here is what my group_var/all looks like:
<br/>
<pre class="lang:default decode:true">contact_name: netdude@packetgeek.net</pre>
<br/>
The result is a file in the input directory called core1a.conf, with the following configuration:
<br/>
<pre class="lang:default decode:true">config t<br/>snmp-server contact netdude@packetgeek.net<br/>end<br/>copy run start<br/><br/></pre>
<br/>
Once the configuration file has been created, the next play is called. This play is responsible for pushing the configuration to each device. It runs a local script called netsible.py. The script takes two arguments. The first is the hostname of the device to access. The second is the location of the configuration file that was created.
<br/>
<br/>
In the background, the script connects to the network device, via SSH, accesses enable mode, reads the configuration file, then executes each command on the router. The script utilizes my netlib library, to make this process simple. Here is the code for the netsible.py script:
<br/>
<pre class="lang:python decode:true">#!/usr/bin/env python<br/><br/>from netlib.netlib.user_creds import simple_yaml<br/>from netlib.netlib.conn_type import SSH<br/><br/>from os.path import expanduser<br/>import sys<br/><br/>creds = simple_yaml()<br/>base_dir = expanduser("~/net-ansible")<br/>hostname = sys.argv[1]<br/>command_file = sys.argv[2]<br/>ssh = SSH(hostname, creds['username'], creds['password'])<br/><br/>ssh.connect()<br/>ssh.set_enable(creds['enable'])<br/><br/>with open(base_dir + "/" + command_file) as f:<br/>    for line in f.readlines():<br/>        line = line.strip()<br/>        ssh.command(line)<br/>f.close()<br/><br/>ssh.close()</pre>
<br/>
If your device is running on a version of code that doesn't support ssh, it would be easy, with the netlib library, to utilize telnet. All you would have to do is import the Telnet library via:
<br/>
<pre class="lang:default decode:true">from netlib.netlib.conn_type import Telnet</pre>
<br/>
Then replace the ssh variable with the Telnet Library.
<br/>
<pre class="lang:default decode:true">ssh = Telnet(hostname, creds['username'], creds['password'])</pre>
<br/>
In the playbook, the 'delegate_to' call tells Ansible to run the command locally on the Ansible master, rather than Ansible connecting to the remote devices directly.
<br/>
<br/>
Here is what it looks like when I run the playbook:
<br/>
<pre class="lang:default decode:true">net-ansible]$ ansible-playbook -i hosts push.yml <br/><br/>PLAY [netdevices] ************************************************************* <br/><br/>TASK: [Create SNMP Configuration] ********************************************* <br/>ok: [darkstar -&gt; 127.0.0.1]<br/>ok: [core1a -&gt; 127.0.0.1]<br/><br/>TASK: [Configure SNMP Contact on network device] ****************************** <br/>changed: [darkstar -&gt; 127.0.0.1]<br/>changed: [core1a -&gt; 127.0.0.1]<br/><br/>PLAY RECAP ******************************************************************** <br/>core1a                     : ok=2    changed=1    unreachable=0    failed=0   <br/>darkstar                   : ok=2    changed=1    unreachable=0    failed=0   <br/><br/>net-ansible]$</pre>
<br/>
This obviously works, but it does have a couple limitations, currently the playbook is not multi-[vendor, platform] ready. To do this, I would need to specify host_vars that define each device by vendor or platoform.
<br/>
<br/>
For example, I could define a variable called 'network_platform' in the host_vars and define each host by platform. I could use the values of IOS, NX-OS, IOS-XR, EOS, or JUN-OS defined as the 'network_platform' in the host_vars. Then when I called my playbooks, it could look like:
<br/>
<pre class="lang:default decode:true">---<br/>- hosts: netdevices<br/>  connection: local<br/>  gather_facts: no<br/>  <br/>  tasks:<br/>  - name: IOS | Create SNMP Configuration<br/>    template:<br/>      src=templates/ios/snmp-contact.j2<br/>      dest=input/{{ "{{" }} hostname }}.conf<br/>    delegate_to: 127.0.0.1<br/>    when: network_platform == IOS<br/><br/>  - name: NX-OS | Create SNMP Configuration<br/>    template:<br/>      src=templates/nx-os/snmp-contact.j2<br/>      dest=input/{{ "{{" }} hostname }}.conf<br/>    delegate_to: 127.0.0.1<br/>    when: network_platform == NX-OS<br/><br/>  - name: IOS-XR | Create SNMP Configuration<br/>    template:<br/>      src=templates/ios-xr/snmp-contact.j2<br/>      dest=input/{{ "{{" }} hostname }}.conf<br/>    delegate_to: 127.0.0.1<br/>    when: network_platform == IOS-XR<br/><br/>  - name: EOS | Create SNMP Configuration<br/>    template:<br/>      src=templates/eos/snmp-contact.j2<br/>      dest=input/{{ "{{" }} hostname }}.conf<br/>    delegate_to: 127.0.0.1<br/>    when: network_platform == EOS<br/><br/>  - name: JUN-OS | Create SNMP Configuration<br/>    template:<br/>      src=templates/jun-os/snmp-contact.j2<br/>      dest=input/{{ "{{" }} hostname }}.conf<br/>    delegate_to: 127.0.0.1<br/>    when: network_platform == JUN-OS<br/><br/>  - name: Configure SNMP Contact on network device<br/>    command: scripts/netsible.py {{ "{{" }} hostname }} input/{{ "{{" }} hostname }}.conf <br/>    delegate_to: 127.0.0.1</pre>
<br/>
The other limitation that is that the script writes the configuration to the network devices every time that the playbook is ran, regardless of whether it's needed or not. For creating an snmp contact, this isn't a huge deal, with the exception of taking extra CPU cycles. However, what if you ran a playbook that was entirely roll based, and it called a role to define BGP route reflectors. Obviously, this would bounce BGP neighbors every time that you ran the playbook. Basically, it boils down to needing a method of checking whether the configuration is actually needed before the script applies it. This is something that I hope to be able to work on. In the mean time, I hope that you've enjoyed this. If you have any ideas, please feel free to share them with me!
<br/>
<br/>
I have a generic Github repository that I've been using to play with
<a href="https://github.com/jtdub/net-ansible" target="_blank">
 Ansible Network Engineering
</a>
functionality. Feel free to play with it and contribute to it! Note that '
<a href="https://github.com/jtdub/netlib" target="_blank">
 netlib
</a>
' is called as a submodule. :) Enjoy!
